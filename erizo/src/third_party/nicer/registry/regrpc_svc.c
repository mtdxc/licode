/*
 *    
 *    Copyright (C) 2006, Network Resonance, Inc.
 *    All Rights Reserved
 *    
 *    Redistribution and use in source and binary forms, with or without
 *    modification, are permitted provided that the following conditions
 *    are met:
 *    
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. Neither the name of Network Resonance, Inc. nor the name of any
 *       contributors to this software may be used to endorse or promote 
 *       products derived from this software without specific prior written
 *       permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *    ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 *    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 *    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 *    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 *    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *    POSSIBILITY OF SUCH DAMAGE.
 *    
 */
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "regrpc.h"
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>
#include <sys/ttycom.h>
#ifdef __cplusplus
#include <sysent.h>
#endif /* __cplusplus */
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <syslog.h>

#ifdef __STDC__
#define SIG_PF void(*)(int)
#endif

#ifdef DEBUG
#define RPC_SVC_FG
#endif

#define _RPCSVC_CLOSEDOWN 120
#if 0
static int _rpcpmstart;		/* Started by a port monitor ? */
static int _rpcfdtype;		/* Whether Stream or Datagram ? */
#endif
static int _rpcsvcdirty;	/* Still serving ? */

#if 0
#include <rpc/svc.h>
extern SVCXPRT *svcfd_create __P((int, u_int, u_int));

static void closedown(void);

static void
closedown()
{
	if (_rpcsvcdirty == 0) {
		extern fd_set svc_fdset;
		static int size;
		int i, openfd;

		if (_rpcfdtype == SOCK_DGRAM)
			exit(0);
		if (size == 0) {
			size = getdtablesize();
		}
		for (i = 0, openfd = 0; i < size && openfd < 2; i++)
			if (FD_ISSET(i, &svc_fdset))
				openfd++;
		if (openfd <= (_rpcpmstart?0:1))
			exit(0);
	}
	(void) alarm(_RPCSVC_CLOSEDOWN);
}
#endif

static nr_regd_result_char *
_nr_reg_get_char_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_char_1_svc(*argp, rqstp));
}

static nr_regd_result_UCHAR *
_nr_reg_get_uchar_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_uchar_1_svc(*argp, rqstp));
}

static nr_regd_result_INT2 *
_nr_reg_get_int2_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_int2_1_svc(*argp, rqstp));
}

static nr_regd_result_UINT2 *
_nr_reg_get_uint2_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_uint2_1_svc(*argp, rqstp));
}

static nr_regd_result_INT4 *
_nr_reg_get_int4_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_int4_1_svc(*argp, rqstp));
}

static nr_regd_result_UINT4 *
_nr_reg_get_uint4_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_uint4_1_svc(*argp, rqstp));
}

static nr_regd_result_INT8 *
_nr_reg_get_int8_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_int8_1_svc(*argp, rqstp));
}

static nr_regd_result_UINT8 *
_nr_reg_get_uint8_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_uint8_1_svc(*argp, rqstp));
}

static nr_regd_result_double *
_nr_reg_get_double_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_double_1_svc(*argp, rqstp));
}

static nr_regd_result_string *
_nr_reg_get_registry_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_registry_1_svc(*argp, rqstp));
}

static nr_regd_result_bytes *
_nr_reg_get_bytes_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_bytes_1_svc(*argp, rqstp));
}

static nr_regd_result_string *
_nr_reg_get_string_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_string_1_svc(*argp, rqstp));
}

static nr_regd_result_UINT4 *
_nr_reg_get_length_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_length_1_svc(*argp, rqstp));
}

static nr_regd_result_string *
_nr_reg_get_type_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_type_1_svc(*argp, rqstp));
}

static int *
_nr_reg_set_char_1(nr_reg_set_char_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_char_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_uchar_1(nr_reg_set_uchar_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_uchar_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_int2_1(nr_reg_set_int2_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_int2_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_uint2_1(nr_reg_set_uint2_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_uint2_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_int4_1(nr_reg_set_int4_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_int4_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_uint4_1(nr_reg_set_uint4_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_uint4_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_int8_1(nr_reg_set_int8_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_int8_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_uint8_1(nr_reg_set_uint8_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_uint8_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_double_1(nr_reg_set_double_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_double_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_registry_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_registry_1_svc(*argp, rqstp));
}

static int *
_nr_reg_set_bytes_1(nr_reg_set_bytes_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_bytes_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_set_string_1(nr_reg_set_string_1_argument *argp, struct svc_req *rqstp)
{
	return(nr_reg_set_string_1_svc(argp->name, argp->data, rqstp));
}

static int *
_nr_reg_del_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_del_1_svc(*argp, rqstp));
}

static int *
_nr_reg_fin_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_fin_1_svc(*argp, rqstp));
}

static nr_regd_result_UINT4 *
_nr_reg_get_child_count_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_child_count_1_svc(*argp, rqstp));
}

static nr_regd_result_strings *
_nr_reg_get_children_1(nr_regd_registry  *argp, struct svc_req *rqstp)
{
	return(nr_reg_get_children_1_svc(*argp, rqstp));
}

static int *
_nr_reg_dump_1(void  *argp, struct svc_req *rqstp)
{
	return(nr_reg_dump_1_svc(rqstp));
}

static int *
_nr_reg_register_for_callbacks_1(int  *argp, struct svc_req *rqstp)
{
	return(nr_reg_register_for_callbacks_1_svc(*argp, rqstp));
}

static void registrydprog_1(struct svc_req *rqstp, SVCXPRT *transp);

static void
registrydprog_1(struct svc_req *rqstp, SVCXPRT *transp)
{
	union {
		nr_regd_registry nr_reg_get_char_1_arg;
		nr_regd_registry nr_reg_get_uchar_1_arg;
		nr_regd_registry nr_reg_get_int2_1_arg;
		nr_regd_registry nr_reg_get_uint2_1_arg;
		nr_regd_registry nr_reg_get_int4_1_arg;
		nr_regd_registry nr_reg_get_uint4_1_arg;
		nr_regd_registry nr_reg_get_int8_1_arg;
		nr_regd_registry nr_reg_get_uint8_1_arg;
		nr_regd_registry nr_reg_get_double_1_arg;
		nr_regd_registry nr_reg_get_registry_1_arg;
		nr_regd_registry nr_reg_get_bytes_1_arg;
		nr_regd_registry nr_reg_get_string_1_arg;
		nr_regd_registry nr_reg_get_length_1_arg;
		nr_regd_registry nr_reg_get_type_1_arg;
		nr_reg_set_char_1_argument nr_reg_set_char_1_arg;
		nr_reg_set_uchar_1_argument nr_reg_set_uchar_1_arg;
		nr_reg_set_int2_1_argument nr_reg_set_int2_1_arg;
		nr_reg_set_uint2_1_argument nr_reg_set_uint2_1_arg;
		nr_reg_set_int4_1_argument nr_reg_set_int4_1_arg;
		nr_reg_set_uint4_1_argument nr_reg_set_uint4_1_arg;
		nr_reg_set_int8_1_argument nr_reg_set_int8_1_arg;
		nr_reg_set_uint8_1_argument nr_reg_set_uint8_1_arg;
		nr_reg_set_double_1_argument nr_reg_set_double_1_arg;
		nr_regd_registry nr_reg_set_registry_1_arg;
		nr_reg_set_bytes_1_argument nr_reg_set_bytes_1_arg;
		nr_reg_set_string_1_argument nr_reg_set_string_1_arg;
		nr_regd_registry nr_reg_del_1_arg;
		nr_regd_registry nr_reg_fin_1_arg;
		nr_regd_registry nr_reg_get_child_count_1_arg;
		nr_regd_registry nr_reg_get_children_1_arg;
		int nr_reg_register_for_callbacks_1_arg;
	} argument;
	char *result;
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(char *, struct svc_req *);

	_rpcsvcdirty = 1;
	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply(transp, (xdrproc_t) xdr_void, (char *)NULL);
		_rpcsvcdirty = 0;
		return;

	case NR_REG_GET_CHAR:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_char;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_char_1;
		break;

	case NR_REG_GET_UCHAR:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UCHAR;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_uchar_1;
		break;

	case NR_REG_GET_INT2:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_INT2;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_int2_1;
		break;

	case NR_REG_GET_UINT2:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UINT2;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_uint2_1;
		break;

	case NR_REG_GET_INT4:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_INT4;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_int4_1;
		break;

	case NR_REG_GET_UINT4:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UINT4;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_uint4_1;
		break;

	case NR_REG_GET_INT8:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_INT8;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_int8_1;
		break;

	case NR_REG_GET_UINT8:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UINT8;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_uint8_1;
		break;

	case NR_REG_GET_DOUBLE:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_double;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_double_1;
		break;

	case NR_REG_GET_REGISTRY:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_string;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_registry_1;
		break;

	case NR_REG_GET_BYTES:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_bytes;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_bytes_1;
		break;

	case NR_REG_GET_STRING:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_string;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_string_1;
		break;

	case NR_REG_GET_LENGTH:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UINT4;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_length_1;
		break;

	case NR_REG_GET_TYPE:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_string;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_type_1;
		break;

	case NR_REG_SET_CHAR:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_char_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_char_1;
		break;

	case NR_REG_SET_UCHAR:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_uchar_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_uchar_1;
		break;

	case NR_REG_SET_INT2:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_int2_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_int2_1;
		break;

	case NR_REG_SET_UINT2:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_uint2_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_uint2_1;
		break;

	case NR_REG_SET_INT4:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_int4_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_int4_1;
		break;

	case NR_REG_SET_UINT4:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_uint4_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_uint4_1;
		break;

	case NR_REG_SET_INT8:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_int8_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_int8_1;
		break;

	case NR_REG_SET_UINT8:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_uint8_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_uint8_1;
		break;

	case NR_REG_SET_DOUBLE:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_double_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_double_1;
		break;

	case NR_REG_SET_REGISTRY:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_registry_1;
		break;

	case NR_REG_SET_BYTES:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_bytes_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_bytes_1;
		break;

	case NR_REG_SET_STRING:
		xdr_argument = (xdrproc_t) xdr_nr_reg_set_string_1_argument;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_set_string_1;
		break;

	case NR_REG_DEL:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_del_1;
		break;

	case NR_REG_FIN:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_fin_1;
		break;

	case NR_REG_GET_CHILD_COUNT:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_UINT4;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_child_count_1;
		break;

	case NR_REG_GET_CHILDREN:
		xdr_argument = (xdrproc_t) xdr_nr_regd_registry;
		xdr_result = (xdrproc_t) xdr_nr_regd_result_strings;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_get_children_1;
		break;

	case NR_REG_DUMP:
		xdr_argument = (xdrproc_t) xdr_void;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_dump_1;
		break;

	case NR_REG_REGISTER_FOR_CALLBACKS:
		xdr_argument = (xdrproc_t) xdr_int;
		xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) _nr_reg_register_for_callbacks_1;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvcdirty = 0;
		return;
	}
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t) &argument)) {
		svcerr_decode(transp);
		_rpcsvcdirty = 0;
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (caddr_t) &argument)) {
		r_log(NR_LOG_REGISTRY, LOG_ERR, "unable to free arguments");
		exit(1);
	}
	_rpcsvcdirty = 0;
	return;
}

#if 0
int main( int argc, char* argv[] );

int
main( int argc, char* argv[] )
{
	SVCXPRT *transp = NULL;
	int sock;
	int proto = 0;
	struct sockaddr_in saddr;
	socklen_t asize = sizeof (saddr);

	if (getsockname(0, (struct sockaddr *)&saddr, &asize) == 0) {
		socklen_t ssize = sizeof (int);

		if (saddr.sin_family != AF_INET)
			exit(1);
		if (getsockopt(0, SOL_SOCKET, SO_TYPE,
				(char *)&_rpcfdtype, &ssize) == -1)
			exit(1);
		sock = 0;
		_rpcpmstart = 1;
		proto = 0;
		openlog("regrpc", LOG_PID, LOG_DAEMON);
	} else {
#ifndef RPC_SVC_FG
		int size;
		int pid, i;

		pid = fork();
		if (pid < 0) {
			perror("cannot fork");
			exit(1);
		}
		if (pid)
			exit(0);
		size = getdtablesize();
		for (i = 0; i < size; i++)
			(void) close(i);
		i = open("/dev/console", 2);
		(void) dup2(i, 1);
		(void) dup2(i, 2);
		i = open("/dev/tty", 2);
		if (i >= 0) {
			(void) ioctl(i, TIOCNOTTY, (char *)NULL);
			(void) close(i);
		}
#endif
		openlog("regrpc", LOG_PID, LOG_DAEMON);
		sock = RPC_ANYSOCK;
		(void) pmap_unset(REGISTRYDPROG, REGISTRYDVERS);
	}

	if ((_rpcfdtype == 0) || (_rpcfdtype == SOCK_DGRAM)) {
		transp = svcudp_create(sock);
		if (transp == NULL) {
			r_log(NR_LOG_REGISTRY, LOG_ERR, "cannot create udp service.");
			exit(1);
		}
		if (!_rpcpmstart)
			proto = IPPROTO_UDP;
		if (!svc_register(transp, REGISTRYDPROG, REGISTRYDVERS, registrydprog_1, proto)) {
			r_log(NR_LOG_REGISTRY, LOG_ERR, "unable to register (REGISTRYDPROG, REGISTRYDVERS, udp).");
			exit(1);
		}
	}

	if ((_rpcfdtype == 0) || (_rpcfdtype == SOCK_STREAM)) {
		if (_rpcpmstart)
			transp = svcfd_create(sock, 0, 0);
		else
			transp = svctcp_create(sock, 0, 0);
		if (transp == NULL) {
			r_log(NR_LOG_REGISTRY, LOG_ERR, "cannot create tcp service.");
			exit(1);
		}
		if (!_rpcpmstart)
			proto = IPPROTO_TCP;
		if (!svc_register(transp, REGISTRYDPROG, REGISTRYDVERS, registrydprog_1, proto)) {
			r_log(NR_LOG_REGISTRY, LOG_ERR, "unable to register (REGISTRYDPROG, REGISTRYDVERS, tcp).");
			exit(1);
		}
	}

	if (transp == (SVCXPRT *)NULL) {
		r_log(NR_LOG_REGISTRY, LOG_ERR, "could not create a handle");
		exit(1);
	}
	if (_rpcpmstart) {
		(void) signal(SIGALRM, (SIG_PF) closedown);
		(void) alarm(_RPCSVC_CLOSEDOWN);
	}
	svc_run();
	r_log(NR_LOG_REGISTRY, LOG_ERR, "svc_run returned");
	exit(1);
	/* NOTREACHED */
}
#endif
